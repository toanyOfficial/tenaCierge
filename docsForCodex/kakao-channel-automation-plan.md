# Kakao 채널 자동 발송 구축 작업 가이드

카카오 채널 메시지를 특정 이벤트/스케줄에 맞춰 자동 발송하기 위해 필요한 작업을 역할별로 정리했습니다. `.env`에 Kakao 키가 이미 배치되어 있고, `schema.csv`/`schema.ddl.sql`에 정의된 테이블을 기준으로 작성했습니다.

## 1. 지금 기준으로 진행 가능한 작업
- **발송 시나리오/이벤트 정의 고도화**: 여섯 가지 이벤트(매일 09:00/15:00 호스트 안내, 배정 시 클리너 안내, 청소 완료 보고 후 버틀러 알림, 매일 16:30 클리너 정산/소모품 안내)를 각각 메시지 유형(알림톡/친구톡), 템플릿 코드, 광고 여부로 구체화할 수 있습니다.
- **수신자 조회 로직 설계**:
  - 호스트: `client_header` → `client_rooms` → `work_header`(또는 `work_*` 관련 스케줄 테이블) 조인을 통해 날짜별 청소 예정 방 목록을 조회하는 SQL 스케치를 준비할 수 있습니다.
  - 클리너: `worker_header` + 배정 테이블(`work_assignments`/`work_header`의 클리너 FK)에서 배정 시점과 방 정보를 조회하는 로직을 설계할 수 있습니다.
  - 버틀러: 청소 완료 보고 테이블(`cleaning_reports` 등)과 근무 스케줄(`worker_schedule` 또는 `work_header`의 버틀러 FK)을 매칭해 당일 근무자 목록을 도출하는 기준을 세울 수 있습니다.
- **메시지 페이로드/템플릿 초안 작성**: 이벤트별로 필요한 필드(객실명, 체크인/아웃, 배정 시간, 정산 금액, 소모품 목록 등)를 정의하고, Kakao 템플릿 변수로 매핑하는 JSON/문구 초안을 만들어 둘 수 있습니다.
- **잡 스케줄링 설계**: Next.js/Node 환경 기준으로 `node-cron` 또는 워커(bull/agenda) 사용 여부, 실행 시각(UTC vs KST 변환) 처리 방식을 정리할 수 있습니다.
- **아키텍처 초안**: "이벤트 → 큐 → 발송 모듈" 흐름, 재시도/로깅 구조(`kakao_message_logs` 등) 설계를 문서화할 수 있습니다.

## 2. 당신이 해야 할 준비/구현 작업
- **카카오 채널/비즈메시지 자격 증명 확정**:
  - `.env`의 `KAKAO_*` 키 값 유효성 확인, 채널ID/발신프로필/템플릿 ID(알림톡 사용 시) 확보.
  - 채널 1:1 발송을 쓸 경우 사용자 `kakao_user_uuid`, 친구/동의 상태를 저장할 DB 테이블(`kakao_channel_subscribers`)을 실제로 생성.
- **DB 필드/테이블 보강 및 데이터 적재**:
  - 템플릿/발신 메타 정보 테이블(`kakao_templates`), 발송 로그 테이블(`kakao_message_logs`), 수신 거부/동의 이력 테이블을 schema.ddl.sql에 맞춰 생성하고 시드 데이터(템플릿 코드, 버튼 JSON 등) 입력.
  - `client_header`, `worker_header`의 전화번호 정규화(하이픈 제거/국제번호) 및 동의 상태(`ad_opt_in_yn` 등) 컬럼 추가 또는 별도 테이블에 적재.
  - 각 이벤트에 필요한 업무 테이블 데이터가 누락되지 않았는지 확인: 예) 배정 정보(`work_assignments` 또는 `work_header`의 assignee 컬럼), 청소 완료 보고 테이블(`cleaning_reports`), 소모품 사용/정산 테이블.
- **발송 템플릿 등록 및 검수**:
  - 알림톡을 사용할 경우 카카오 비즈메시지 센터에 템플릿을 등록해 검수 완료(광고 표기, 수신 거부 문구 포함).
  - 템플릿 변수 키를 DB/코드에 동일하게 반영하고, 버튼(상세 보기, 재배정 요청 등) 링크를 확정.
- **스케줄/이벤트 트리거 연결**:
  - 09:00/15:00/16:30 잡을 서버 타임존(KST) 기준으로 등록하고, 배포 환경(단일 인스턴스 vs 다중)에서 중복 실행 방지 락 적용.
  - 배정/완료 이벤트 발생 시 발송 모듈을 호출하도록 서비스 로직 훅을 추가(예: 배정 API 완료 후 큐에 enqueue, 보고서 저장 후 알림 발송 등).
- **모니터링/장애 대응 준비**:
  - 발송 성공/실패 로그 적재 및 관리자 알림(슬랙/이메일) 설정.
  - 월별 비용 집계 및 메시지별 단가 저장을 위한 필드(`price`) 수집.
- **테스트/검증**:
  - 스테이징 채널에서 샘플 데이터를 넣어 실제 발송까지 E2E 테스트.
  - 전화번호 없는 사용자, 동의 미수집 사용자, 템플릿 변수 누락 등 예외 케이스 테스트.

## 이벤트별 데이터 소스 체크리스트
| 이벤트 | 주요 조회 테이블 | 필수 컬럼/데이터 |
| --- | --- | --- |
| 15:00 호스트(내일 방) | `client_header`, `client_rooms`, 예약/작업 스케줄 테이블(`work_header` 등) | 호스트명/전화, 객실명, 청소 예정일, 체크인/아웃, 특이사항 |
| 09:00 호스트(당일 방) | 동일 | 동일 |
| 클리너 배정 시 | `worker_header`, 배정 테이블 | 클리너명/전화, 객실명, 일정, 집합 시각/위치, 담당 버틀러 |
| 청소 완료 보고 시 | 완료 보고 테이블, `worker_schedule`/버틀러 지정 컬럼 | 보고 일시, 객실, 담당 클리너, 근무 중 버틀러 연락처 |
| 16:30 클리너 정산/랭킹 | 정산/평가 테이블, `worker_header` | 일급, 랭킹 변화, 코멘트, 작업 건수 |
| 16:30 소모품 안내 | 소모품 사용/청구 테이블 | 품목, 수량, 금액, 정산 방식 |

위 준비를 마치면, 발송 SDK/HTTP 클라이언트로 Kakao API를 호출하는 코드와 크론/이벤트 트리거만 구현하면 됩니다.

---

## 모바일 앱/웹 푸시 전달 동작 정리 ("인터넷" 앱/웹 푸시 가정)
- **사전 조건**: 사용자가 브라우저/앱에서 푸시 권한을 허용했고, 최신 푸시 토큰(웹 푸시의 경우 Service Worker 등록 + VAPID 구독 정보)이 서버에 저장되어 있어야 함.
- **1) 인터넷 앱 푸시를 차단한 경우**: 브라우저/앱에서 알림을 차단하면 푸시가 도착하지 않으며, 서버는 보낸 것으로 처리될 수 있으나 실제 표시 없음 → 대안 채널(SMS/카카오) 필요.
- **2) 해당 사이트를 열어 두지 않은 경우**: 웹 푸시는 브라우저가 백그라운드여도 Service Worker가 등록되어 있고 권한이 허용되어 있으면 알림이 표시됨. 단, 오래 미접속하여 구독 토큰이 만료되면 전송 실패 가능.
- **3) 오래전에 띄워둔 탭(장기 미접속)인 경우**: 브라우저에 따라 며칠 이상 미사용 시 Service Worker가 회수되거나 푸시 구독이 만료될 수 있음 → 발송 시 410/404 계열 응답이 나면 재구독을 유도하거나 토큰을 정리해야 함.
- **4) 로그아웃된 상태인 경우**: 푸시 토큰이 계정 단위로 저장되어 있으면 로그아웃 후에는 토큰을 무효화하거나 폐기해야 함. 무효화되지 않은 토큰으로 발송 시 브라우저는 알림을 표시할 수 있지만, 개인정보 보호 관점에서 토큰 정리 정책이 필요.
- **기본 권장**: 푸시는 "허용 + 유효 토큰 + 최근 방문"이 충족될 때만 안정적으로 표시되므로, 핵심 알림은 카카오 알림톡/SMS와 병행하여 폴백을 두는 것이 안전함.

---

## Kakao 자동 발송 이벤트 정의서 (최종본)

### 1. 이벤트 개요
**이벤트명:** 15:00 호스트 – 내일 청소 예정 객실 안내

**목적:**
- 호스트가 내일 예정된 청소 작업을 사전에 직접 확인하여 객실 누락, 일정 오류, 잘못된 배정을 조기에 점검하기 위함.

### 2. 발송 트리거 (When)
- **발송 시각:** 매일 15:00 (KST 기준)
- **발송 조건:**
  - 내일 날짜(D+1)에 청소(work)가 존재하는 호스트 **또는** 내일 청소 예정 건수가 0건인 호스트(둘 모두 하루 1회)
  - 동일 호스트 기준 하루 1회만 발송

### 3. 수신자 정의 (Who)
- **수신자:** 호스트
- **기준 테이블:** `client_header`, `client_rooms`, `work_header`(또는 청소 스케줄 테이블)
- **필수 조건:**
  - 호스트 전화번호 존재
  - 카카오 메시지 수신 동의 상태 = Y

### 4. 메시지 유형
- **메시지 유형:** 알림톡
- **광고 여부:** 비광고

### 5. 메시지 본문

```
{{ client.name }} 님의 내일자({{ yyyy-MM-dd }}) 청소 건은
총 {{ n }}건입니다.

- {{ building_short_name }} {{ room_no }}
- {{ building_short_name }} {{ room_no }}
- {{ building_short_name }} {{ room_no }}

확인 후 특이사항이 있으시면 편하게 말씀 주세요.
수정사항이 있다면 16:00까지 반드시 직접 수정 부탁드립니다.
```

청소 예정 건수가 0건인 경우(동일 변수 포맷 유지, `client.name`/`yyyy-MM-dd` 동일) 메시지:

```
{{ client.name }} 님,
내일자({{ yyyy-MM-dd }}) 청소 대상 객실이 없습니다.

추가 예약이나 변경이 필요하면 16:00까지 말씀해 주세요.
```

### 6. 메시지 변수 정의 (What)

| 변수명 | 설명 | 데이터 소스 |
| --- | --- | --- |
| client.name | 호스트 이름 | `client_header.name` |
| yyyy-MM-dd | 내일 날짜 (D+1) | 서버 기준 |
| n | 내일 청소 예정 총 건수 | `work_header` count |
| building_short_name | 건물 축약명 | `client_rooms.building_short_name` |
| room_no | 객실 호수 | `client_rooms.room_no` |

### 7. 데이터 조회 기준
- **조회 기준일:** 내일 (D+1)
- **조건:**
  - `work_header.work_date = D+1`
  - 취소 상태 work 제외
- **호스트 기준 그룹핑:**
  - 총 작업 건수(n) 계산
  - 객실 목록 리스트업
  - `n = 0`인 호스트도 추출하여 별도 템플릿으로 발송

### 8. 리스트 출력 규칙
- 동일 호스트의 여러 객실은 리스트 형태로 출력
- 정렬 기준: `building_short_name` → `room_no` 오름차순(권장)

### 9. 중복 발송 방지 및 로그
- 발송 성공/실패 여부를 `kakao_message_logs`에 기록
- 동일 호스트 + 동일 날짜 + 동일 이벤트 키 기준으로 중복 발송 방지 처리

### 10. 예외 처리
- 전화번호 없음 → 발송하지 않음
- 수신 동의 없음 → 발송하지 않음
- 메시지 변수 누락 → 발송 실패 처리 및 로그 적재
